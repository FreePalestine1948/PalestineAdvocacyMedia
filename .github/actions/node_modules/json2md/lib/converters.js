"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var converters = module.exports = {};

var generateHeader = function generateHeader(repeat) {
    return function (input, json2md) {
        return "#".repeat(repeat) + " " + json2md(input);
    };
};

var indent = function indent(content, spaces, ignoreFirst) {
    var lines = content;

    if (typeof content === "string") {
        lines = content.split("\n");
    }

    if (ignoreFirst) {
        if (lines.length <= 1) {
            return lines.join("\n");
        }
        return lines[0] + "\n" + indent(lines.slice(1), spaces, false);
    }

    return lines.map(function (c) {
        return " ".repeat(spaces) + c;
    }).join("\n");
};

var parseTextFormat = function parseTextFormat(text) {

    var formats = {
        strong: "**",
        italic: "*",
        underline: "_",
        strikethrough: "~~"
    };

    return text.replace(/<\/?strong\>/gi, formats.strong).replace(/<\/?bold\>/gi, formats.strong).replace(/<\/?em\>/gi, formats.italic).replace(/<\/?italic\>/gi, formats.italic).replace(/<\/?u\>/gi, formats.underline).replace(/<\/?strike\>/gi, formats.strikethrough);
};

// Headings
converters.h1 = generateHeader(1);
converters.h2 = generateHeader(2);
converters.h3 = generateHeader(3);
converters.h4 = generateHeader(4);
converters.h5 = generateHeader(5);
converters.h6 = generateHeader(6);

converters.blockquote = function (input, json2md) {
    return json2md(input, "> ");
};

converters.img = function (input, json2md) {

    debugger;
    if (Array.isArray(input)) {
        return json2md(input, "", "img");
    }
    if (typeof input === "string") {
        return converters.img({ source: input, title: "", alt: "" });
    }
    input.title = input.title || "";
    input.alt = input.alt || "";
    return "![" + input.alt + "](" + input.source + " \"" + input.title + "\")";
};

converters.ul = function (input, json2md) {
    var c = "";
    for (var i = 0; i < input.length; ++i) {
        var marker = "";

        var type = Object.keys(input[i])[0];
        if (type !== "ul" && type !== "ol" && type !== 'taskLists') {
            marker += "\n - ";
        }

        c += marker + parseTextFormat(indent(json2md(input[i]), 4, true));
    }
    return c;
};

converters.ol = function (input, json2md) {
    var c = "";
    var jumpCount = 0;
    for (var i = 0; i < input.length; ++i) {
        var marker = "";
        var type = Object.keys(input[i])[0];
        if (type !== "ul" && type !== "ol" && type !== 'taskLists') {
            marker = "\n " + (i + 1 - jumpCount) + ". ";
        } else {
            jumpCount++;
        }

        c += marker + parseTextFormat(indent(json2md(input[i]), 4, true));
    }
    return c;
};

converters.taskLists = function (input, json2md) {
    var c = "";
    for (var i = 0; i < input.length; ++i) {
        var marker = "";

        var type = Object.keys(input[i])[0];
        if (type !== "ul" && type !== "ol" && type !== 'taskLists') {
            marker += input[i].isDone ? "\n - [x] " : "\n - [ ] ";
        }

        c += marker + parseTextFormat(indent(json2md(input[i].title || input[i]), 4, true));
    }
    return c;
};

converters.code = function (input, json2md) {
    var c = "```" + (input.language || "") + "\n";
    if (Array.isArray(input.content)) {
        c += input.content.join("\n");
    } else {
        c += input.content;
    }
    c += "\n```";
    return c;
};

converters.p = function (input, json2md) {
    return parseTextFormat(json2md(input, "\n"));
};

converters.table = function (input, json2md) {
    var _PREFERRED_LENGTH_PER;

    var ALIGNMENT = {
        CENTER: 'center',
        RIGHT: 'right',
        LEFT: 'left',
        NONE: 'none'
    };

    var PREFERRED_LENGTH_PER_ALIGNMENT = (_PREFERRED_LENGTH_PER = {}, _defineProperty(_PREFERRED_LENGTH_PER, ALIGNMENT.CENTER, 3), _defineProperty(_PREFERRED_LENGTH_PER, ALIGNMENT.RIGHT, 2), _defineProperty(_PREFERRED_LENGTH_PER, ALIGNMENT.LEFT, 2), _defineProperty(_PREFERRED_LENGTH_PER, ALIGNMENT.NONE, 1), _PREFERRED_LENGTH_PER);

    if ((typeof input === "undefined" ? "undefined" : _typeof(input)) !== "object" || !input.hasOwnProperty("headers") || !input.hasOwnProperty("rows")) {
        return "";
    }

    var alignment = input.headers.map(function (_, index) {
        return input.aligns && input.aligns[index] ? input.aligns[index] : ALIGNMENT.NONE;
    });

    // try to match the space the column name and the dashes (and colons) take up. Minimum depends on alignment
    var preferred_lengths = input.headers.map(function (header, index) {
        return Math.max(PREFERRED_LENGTH_PER_ALIGNMENT[alignment[index]], header.length - 2);
    });

    if (input.pretty === true) {
        // update preferred_lengths considering rows' cells length
        input.rows.forEach(function (row) {
            (Array.isArray(row) ? row : input.headers.map(function (col_id) {
                return row[col_id];
            })).forEach(function (cell, index) {
                preferred_lengths[index] = Math.max(preferred_lengths[index], cell.length - 2);
            });
        });
    }

    var fill_right = function fill_right(diff, header) {
        return " ".repeat(diff) + header;
    };
    var fill_left = function fill_left(diff, header) {
        return header + " ".repeat(diff);
    };
    var fill_center = function fill_center(diff, header) {
        return " ".repeat(Math.floor(diff / 2)) + header + " ".repeat(Math.ceil(diff / 2));
    };

    var fill_th = function fill_th(header, index) {
        var diff = preferred_lengths[index] + 2 - header.length;
        switch (alignment[index]) {
            case ALIGNMENT.RIGHT:
                return fill_right(diff, header);
            case ALIGNMENT.LEFT:
                return fill_left(diff, header);
            case ALIGNMENT.CENTER:
            case ALIGNMENT.NONE:
            default:
                return fill_center(diff, header);
        }
    };

    var fill_td = function fill_td(header, index) {
        var diff = preferred_lengths[index] + 2 - header.length;
        switch (alignment[index]) {
            case ALIGNMENT.RIGHT:
                return fill_right(diff, header);
            case ALIGNMENT.NONE:
            case ALIGNMENT.LEFT:
                return fill_left(diff, header);
            case ALIGNMENT.CENTER:
            default:
                return fill_center(diff, header);
        }
    };

    // add spaces around column name if necessary (side(s) depends on alignment)
    var column_names = input.headers.map(fill_th);

    var header = "| " + column_names.join(" | ") + " |";

    var spaces = "| " + input.headers.map(function (_, index) {
        var inner = "-".repeat(preferred_lengths[index]);
        switch (alignment[index]) {
            case ALIGNMENT.CENTER:
                return ":" + inner + ":";
            case ALIGNMENT.RIGHT:
                return "-" + inner + ":";
            case ALIGNMENT.LEFT:
                return ":" + inner + "-";
            case ALIGNMENT.NONE:
            default:
                return "-" + inner + "-";
        }
    }).join(" | ") + " |";

    var fill_tbody_cell = function fill_tbody_cell(cell, index) {
        if (input.pretty !== true) return cell;
        return fill_td(cell, index);
    };

    var data = input.rows.map(function (row) {
        return "| " + (Array.isArray(row) ? row : input.headers.map(function (col_id) {
            return row[col_id];
        })).map(function (cell) {
            return json2md(cell);
        }).map(function (cell) {
            return parseTextFormat(cell);
        }).map(function (cell) {
            return cell.replace(/([^\\])\|/, "$1\\|");
        }).map(function (cell) {
            return cell.trim();
        }).map(fill_tbody_cell).join(" | ") + " |";
    }).join("\n");

    return [header, spaces, data].join("\n");
};

converters.link = function (input, json2md) {
    if (Array.isArray(input)) {
        return json2md(input, "", "link");
    }
    if (typeof input === "string") {
        return converters.link({ source: input, title: "" });
    }
    return "[" + input.title + "](" + input.source + ")";
};

converters.hr = function (input, json2md) {
    return '---';
};